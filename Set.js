// Generated by CoffeeScript 1.6.3
/*
This small library extends the JavaScript Array object
to work as a sorted Set using the provided methods.

Set Properties:
* Sorted in Ascending Order
* No Duplicate Indexes
* Uniform Type

All types of elements will work as long as you pass the attribute paramater
to be used during comparisons (>,<,==,etc.).
*/

var Set;

Set = (function() {
  function Set(elements, attribute, primer) {
    var ele, _i, _len;
    this.elements = [];
    this.attribute = attribute != null ? attribute : false;
    this.key_primer = primer != null ? primer : function(ele) {
      return ele;
    };
    if (elements && elements[0]) {
      this.type = typeof elements[0];
      for (_i = 0, _len = elements.length; _i < _len; _i++) {
        ele = elements[_i];
        this.insert(ele);
      }
    } else {
      this.type = void 0;
    }
  }

  /*
  	(A \ B) = {x: x∈A ∧ x∉B }
  */


  Set.prototype.difference = function(set) {
    var a, a_arr, a_max, a_ptr, b, b_arr, b_max, b_ptr, c, c_arr, c_ptr;
    if (this.type !== set.type) {
      new Set([]);
    }
    b = set;
    a = this;
    a_ptr = 0;
    a_max = a.elements.length;
    a_arr = a.elements;
    b_ptr = 0;
    b_max = b.elements.length;
    b_arr = b.elements;
    c = new Set([]);
    c_arr = c.elements;
    c_ptr = 0;
    while ((a_ptr <= a_max) && (b_ptr <= b_max) && !(a_ptr === a_max && b_ptr === b_max)) {
      if (this.primer(a_arr[a_ptr]) === this.primer(b_arr[b_ptr])) {
        a_ptr++;
        b_ptr++;
      } else if (b_ptr === b_max) {
        c_arr[c_ptr] = a_arr[a_ptr];
        a_ptr++;
        c_ptr++;
      } else if (a_ptr === a_max) {
        break;
      } else if (this.primer(a_arr[a_ptr]) > this.primer(b_arr[b_ptr])) {
        b_ptr++;
      } else if (this.primer(a_arr[a_ptr]) < this.primer(b_arr[b_ptr])) {
        c_arr[c_ptr] = a_arr[a_ptr];
        a_ptr++;
        c_ptr++;
      } else {
        break;
      }
    }
    return c;
  };

  /*
  	Finds the index of an element in the Set.
  */


  Set.prototype.find = function(key) {
    var high, low, mid, target;
    low = 0;
    high = this.elements.length - 1;
    while (low <= high) {
      mid = Math.floor((low + high) / 2);
      target = this.primer(this.elements[mid]);
      if (key === target) {
        return mid;
      } else if (key > target) {
        low = mid + 1;
      } else {
        high = mid - 1;
      }
    }
    return -1;
  };

  /*
  	Returns an element from the Set.
  */


  Set.prototype.get = function(key) {
    return this.elements[this.find(key)];
  };

  /*
  	Checks if an element is in the set
  */


  Set.prototype.has = function(key) {
    if (this.find(key) !== -1) {
      return true;
    } else {
      return false;
    }
  };

  /*
  	Inserts an element into the Set maintaining sorted order.
  */


  Set.prototype.insert = function(ele) {
    var high, high_target, key, low, low_target, mid, mid_target;
    if (this.elements.length === 0) {
      this.elements[0] = ele;
      this.type = typeof ele;
    } else if (this.type !== typeof ele) {
      console.log("mismatched set element type");
    } else {
      low = 0;
      high = this.elements.length - 1;
      while (low <= high) {
        mid = Math.floor((low + high) / 2);
        key = this.primer(ele);
        mid_target = this.primer(this.elements[mid]);
        low_target = this.primer(this.elements[low]);
        high_target = this.primer(this.elements[high]);
        if (high_target < key) {
          mid = high + 1;
          break;
        } else if (low_target > key) {
          mid = low;
          break;
        } else if (mid_target < key) {
          low = mid + 1;
        } else {
          high = mid - 1;
        }
      }
      if (this.primer(this.elements[mid]) !== this.primer(ele)) {
        [].splice.apply(this.elements, [mid, mid - mid].concat(ele)), ele;
      }
    }
    return this;
  };

  /*
  	(A ∩ B) = {x: x∈A ∧ x∈B}
  */


  Set.prototype.intersect = function(set) {
    var a, a_arr, a_max, a_ptr, b, b_arr, b_max, b_ptr, c, c_arr, c_ptr;
    if (this.type !== set.type) {
      new Set([]);
    }
    b = set;
    a = this;
    a_ptr = 0;
    a_max = this.elements.length;
    a_arr = this.elements;
    b_ptr = 0;
    b_max = b.elements.length;
    b_arr = b.elements;
    c = new Set([]);
    c_arr = c.elements;
    c_ptr = 0;
    while ((a_ptr <= a_max) && (b_ptr <= b_max) && !(a_ptr === a_max && b_ptr === b_max)) {
      if ((this.primer(a_arr[a_ptr]) > this.primer(b_arr[b_ptr]) && b_ptr === b_max) || (this.primer(b_arr[b_ptr]) > this.primer(a_arr[a_ptr]) && a_ptr === a_max)) {
        break;
      } else if (this.primer(a_arr[a_ptr]) === this.primer(b_arr[b_ptr])) {
        c_arr[c_ptr] = a_arr[a_ptr];
        a_ptr++;
        b_ptr++;
        c_ptr++;
      } else if (b_ptr === b_max) {
        a_ptr++;
      } else if (a_ptr === a_max) {
        b_ptr++;
      } else if (this.primer(a_arr[a_ptr]) > this.primer(b_arr[b_ptr])) {
        b_ptr++;
      } else if (this.primer(a_arr[a_ptr]) < this.primer(b_arr[b_ptr])) {
        a_ptr++;
      } else {
        break;
      }
    }
    return c;
  };

  Set.prototype.primer = function(ele) {
    if (ele === void 0) {
      return ele;
    } else if (this.attribute && ele[this.attribute]) {
      return this.key_primer(ele[this.attribute]);
    } else {
      return this.key_primer(ele);
    }
  };

  /*
  	Removes an element from the Set.
  */


  Set.prototype.remove = function(key) {
    var index, _ref;
    index = this.find(key);
    if (index !== -1) {
      [].splice.apply(this.elements, [index, 9e9].concat(_ref = this.elements.slice(index + 1))), _ref;
    }
    return this;
  };

  /*
  	Returns the size (or length) of the set.
  */


  Set.prototype.size = function() {
    return this.elements.length;
  };

  /*
  	(A ⊆ B) = {x: ∀x∈A x∈B}
  */


  Set.prototype.subset = function(set) {
    var a, a_arr, a_max, a_ptr, b, b_arr, b_max, b_ptr;
    if (this.type !== set.type) {
      false;
    }
    b = set;
    a = this;
    a_ptr = 0;
    a_max = this.elements.length;
    a_arr = this.elements;
    b_ptr = 0;
    b_max = b.elements.length;
    b_arr = b.elements;
    while (a_ptr <= a_max && b_ptr <= b_max && !(a_ptr === a_max && b_ptr === b_max)) {
      if (this.primer(a_arr[a_ptr]) === this.primer(b_arr[b_ptr])) {
        a_ptr++;
        b_ptr++;
      } else if (a_ptr === a_max) {
        return true;
      } else if (b_ptr === b_max || this.primer(a_arr[a_ptr]) < this.primer(b_arr[b_ptr])) {
        return false;
      } else if (this.primer(a_arr[a_ptr]) > this.primer(b_arr[b_ptr])) {
        b_ptr++;
      } else {
        return false;
      }
    }
    return true;
  };

  /*
  	(A ⊇ B) = {x: ∀x∈B x∈A}
  */


  Set.prototype.superset = function(set) {
    var b;
    b = set;
    return b.subset(this);
  };

  /*
  	(A ∆ B) = {x: (x∈A ⋁ x∈B) ∧ !(x∈A ∧ x∈B) }
  */


  Set.prototype.symmetricDifference = function(set) {
    var a, a_arr, a_max, a_ptr, b, b_arr, b_max, b_ptr, c, c_arr, c_ptr;
    if (this.type !== set.type) {
      new Set([]);
    }
    b = set;
    a = this;
    a_ptr = 0;
    a_max = this.elements.length;
    a_arr = this.elements;
    b_ptr = 0;
    b_max = b.elements.length;
    b_arr = b.elements;
    c = new Set([]);
    c_arr = c.elements;
    c_ptr = 0;
    while (a_ptr <= a_max && b_ptr <= b_max && !(a_ptr === a_max && b_ptr === b_max)) {
      if (this.primer(a_arr[a_ptr]) === this.primer(b_arr[b_ptr])) {
        a_ptr++;
        b_ptr++;
      } else if (a_ptr === a_max) {
        c_arr[c_ptr] = b_arr[b_ptr];
        b_ptr++;
        c_ptr++;
      } else if (b_ptr === b_max) {
        c_arr[c_ptr] = a_arr[a_ptr];
        a_ptr++;
        c_ptr++;
      } else if (this.primer(a_arr[a_ptr]) < this.primer(b_arr[b_ptr])) {
        c_arr[c_ptr] = a_arr[a_ptr];
        a_ptr++;
        c_ptr++;
      } else if (this.primer(a_arr[a_ptr]) > this.primer(b_arr[b_ptr])) {
        c_arr[c_ptr] = b_arr[b_ptr];
        b_ptr++;
        c_ptr++;
      } else {
        break;
      }
    }
    return c;
  };

  /*
  	(A ∪ B) = {x: x∈A ∨ x∈B }
  */


  Set.prototype.union = function(set) {
    var a, a_arr, a_max, a_ptr, b, b_arr, b_max, b_ptr, c, c_arr, c_ptr;
    if (this.type !== set.type) {
      new Set([]);
    }
    b = set;
    a = this;
    a_ptr = 0;
    a_max = this.elements.length;
    a_arr = this.elements;
    b_ptr = 0;
    b_max = b.elements.length;
    b_arr = b.elements;
    c = new Set([]);
    c_arr = c.elements;
    c_ptr = 0;
    while (a_ptr <= a_max && b_ptr <= b_max && !(a_ptr === a_max && b_ptr === b_max)) {
      if (b_ptr === b_max) {
        c_arr[c_ptr] = a_arr[a_ptr];
        a_ptr++;
        c_ptr++;
      } else if (a_ptr === a_max) {
        c_arr[c_ptr] = b_arr[b_ptr];
        b_ptr++;
        c_ptr++;
      } else if (this.primer(a_arr[a_ptr]) === this.primer(b_arr[b_ptr])) {
        c_arr[c_ptr] = a_arr[a_ptr];
        a_ptr++;
        b_ptr++;
        c_ptr++;
      } else if (this.primer(a_arr[a_ptr]) > this.primer(b_arr[b_ptr])) {
        c_arr[c_ptr] = b_arr[b_ptr];
        b_ptr++;
        c_ptr++;
      } else if (this.primer(a_arr[a_ptr]) < this.primer(b_arr[b_ptr])) {
        c_arr[c_ptr] = a_arr[a_ptr];
        a_ptr++;
        c_ptr++;
      } else {
        break;
      }
    }
    return c;
  };

  return Set;

})();

if (typeof window === 'undefined') {
  exports.Set = Set;
} else {
  window.Set = Set;
}
